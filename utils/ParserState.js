'use strict';

/// @param parser Генератор, аккумулирующий блоки и возвращаающий результат разбора,
///        как только у него будет достаточно блоков для этого. Свойство `value`
///        возвращаемого объекта содержит либо результат разбора, в случае, если разбор
///        завершен, либо число, определяющее минимальное количество данных, требуемое
///        парсеру для завершения разбора
/// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
///        Может быть генератором, т.к. в его метод `next` передается число, означающее
///        количество символов, требуемое парсеру для завершения разбора текущей порции.
function _parse(parser, input) {
  // Сначала пытаемся получить результат непосредственно, возможно, что данных в буфере
  // уже достаточно
  let res = parser.next();

  // Если данных в буфере оказалось недостаточно, запрашиваем очередную порцию.
  while (!res.done) {
    // Передаем источнику размер данных, которые нам нужны для принятия решения
    let chunk = input.next(res.value);
    // Отправляем парсеру очередную порцию данных
    res = parser.next(chunk);
  }
  return res.value;
}

class State {
  constructor(buffer) {
    // Данные, доступные для разбора
    this.buffer = buffer ? buffer : '';
    // Сколько данных из буфера уже поглощено
    this.offset = 0;

    // Признак необходимости регистрации ожидаемых значений. Значения регистрируются,
    // как ожидаемые только в том случае, если он равен 0.
    this.silentFail = 0;
    // Максимальное смещение, до которого удалось добраться при разборе
    this.maxFailOffset = 0;
    // Список ожидаемых значений на смещении `maxFailOffset`.
    this.maxFailExpected = [];
  }
  /// Помещает новую порцию данных в список доступных данных для разбора
  /// @param chunk Порция данных, полученная от итератора с разбираемой последовательностью.
  /// @return `true`, если добавленная порция является последней, иначе `false`
  push(chunk) {
    if (chunk.value) {
      this.buffer += chunk.value;
    }
    return chunk.done;
  }
  neededData(count) {
    return this.offset + count - this.buffer.length;
  }
  charAt(offset) {
    return this.buffer.charAt(offset);
  }
  substr(length) {
    return this.buffer.substr(this.offset, length);
  }
  fail(expected) {
    if (this.silentFail > 0) { return; }
    if (this.offset < this.maxFailOffset) { return; }

    if (this.offset > this.maxFailOffset) {
      this.maxFailOffset = this.offset;
      this.maxFailExpected = [];
    }

    this.maxFailExpected.push(expected);
    return State.FAILED;
  }

  /// Возвращает генератор, который при каждом вызове пытается извлечь символ из
  /// потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает 1 символ из разбираемого потока и приостанавливает свою работу
  /// до его получения.
  ///
  /// Как только символ будет получен, возвращает его. Если поток окончится до того,
  /// как вернет символ, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе.
  ///
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchAny(last) {
    while (true) {
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      if (this.neededData(1) <= 0) {
        return this.charAt(this.offset++);
      }
      if (last) {
        return this.fail(State.ANY);
      }
      // В противном случае запрашиваем данные длиной как минимум в 1 символ
      // и повторяем процедуру
      last = this.push(yield 1);
    }
  }
  /// Возвращает генератор, который при каждом вызове пытается извлечь символ из
  /// потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает 1 символ из разбираемого потока и приостанавливает свою работу
  /// до его получения.
  ///
  /// Как только символ будет получен, проверяет его на соответствие указанному
  /// регулярному выражению. Если проверка будет провалена или поток окончится до того,
  /// как вернет символ, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе. В противном случае будет возвращен символ, полученный из потока.
  ///
  /// @param regexp {RegExp} Объект регулярного выражения, с которым сопоставлять полученный
  ///        из потока символ. Выражение должно ожидать только один символ на входе.
  /// @param expected {Expected} Объект, представляющий структурированную информацию об
  ///        ожидаемых парсером данных, который может быть зарегистрирован в списке ожидаемой
  ///        информации в случае, если разбор будет неуспешен.
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchClass(regexp, expected, last) {
    while (true) {
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      if (this.neededData(1) <= 0) {
        let ch = this.charAt(this.offset);
        if (regexp.test(ch)) {
          ++this.offset;
          return ch;
        }
        return this.fail(expected);
      }
      if (last) {
        return this.fail(expected);
      }
      // В противном случае запрашиваем данные длиной как минимум в 1 символ
      // и повторяем процедуру
      last = this.push(yield 1);
    }
  }
  /// Возвращает генератор, который при каждом вызове пытается извлечь `literal.length`
  /// символов из потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает недостающее количество символов из разбираемого потока и приостанавливает
  /// свою работу до их получения.
  ///
  /// Как только все символы будут получены, проверяет их на соответствие указанному
  /// литералу, с учетем флага необходимости игнорирования регистра символов при сравнении.
  /// Если проверка будет провалена или поток окончится до того, как вернет необходимое
  /// количество символов, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе. В противном случае будет возвращена последовательность потока,
  /// соответствующая указанному литералу.
  ///
  /// @param literal {String} Строка, на равенство которой необходимо проверить символы в потоке.
  /// @param ignoreCase {boolean} `true`, если сравнение нужно производить без учета регистра
  ///        и `false` иначе.
  /// @param expected {Expected} Объект, представляющий структурированную информацию об
  ///        ожидаемых парсером данных, который может быть зарегистрирован в списке ожидаемой
  ///        информации в случае, если разбор будет неуспешен.
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchLiteral(literal, ignoreCase, expected, last) {
    while (true) {
      let needed = this.neededData(literal.length);
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      // TODO: Включить оптимизацию для длинных строк: пытаться определить провал
      // сопоставления еще до получения всей строки
      if (needed <= 0) {
        let data = this.substr(literal.length);
        let forCompare = ignoreCase ? data.toLowerCase() : data;
        if (forCompare === literal) {
          this.offset += data.length;
          return data;
        }
        return this.fail(expected);
      }
      if (last) {
        return this.fail(expected);
      }
      // В противном случае запрашиваем данные длиной с недостающий размер строки
      // и повторяем процедуру
      last = this.push(yield needed);
    }
  }

  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseAny(input) {
    return _parse(this.matchAny(), input);
  }
  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseClass(input, regexp, expected) {
    return _parse(this.matchClass(regexp, expected), input);
  }
  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseLiteral(input, literal, ignoreCase, expected) {
    return _parse(this.matchLiteral(literal, ignoreCase, expected), input);
  }
}
/// Константа, сигнализирующая о неуспешном разборе правила
State.FAILED = function FAILED(){};
/// Константа, описывающая ожидаемый результат любого символа последовательности
State.ANY = { type: "any" };

module.exports = State;