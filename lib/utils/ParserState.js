'use strict';

/// Буфер, хранящий данные порциями и могущий не хранить устаревшие порции для экономии
/// памяти.
class Buf {
  constructor(chunk) {
    // Набор порций с реальными данными. Порции покрывают все виртуальное пространство
    // буфера без пропусков и наложений
    this.chunks = chunk ? [chunk] : [];
    // Пары смещений для каждой порции, содержащие начальное и конечное смещение в буфере,
    // которые покарывает даннаяпорция. Т.к. порции идут впритык, но конец одной является
    // началом другой, поэтому хранятся только концы каждой порции плюс начало самой первой
    // порции
    this.bounds = chunk ? [0, chunk.length] : [0];
    // Общее количество данных в буфере
    this.length = chunk ? chunk.length : 0;
  }
  /// Добавляет в буфер новую порцию данных.
  push(chunk) {
    if (chunk.length === 0) { return }

    this.length += chunk.length;
    this.bounds.push(this.length);
    this.chunks.push(chunk);
  }
  /// Выкидывает из буфера все порции, хранящие данные ранее указанного смещения
  strip(offset) {
    let i = this.findIndex(offset);
    this.bounds.splice(0, i);
    this.chunks.splice(0, i);
  }
  charAt(offset) {
    let i = this.findIndex(offset);
    let j = offset - this.bounds[i];
    return this.chunks[i].charAt(j);
  }
  substr(offset, length) {
    let s = this.findIndex(offset);
    let j = offset - this.bounds[s];

    // Запрошенные данные находятся внутри одной порции
    let chunk = this.chunks[s];
    if (j + length <= chunk.length) {
      return chunk.substr(j, length);
    }

    // Запрошенные данные внутри нескольких порций
    let r = [chunk.substr(j)];
    length -= chunk.length - j;
    for (let i = s + 1; i <= this.chunks.length; ++i) {
      let chunk = this.chunks[i];
      if (chunk.length < length) {
        r.push(chunk);
        length -= chunk.length;
      } else {
        r.push(chunk.substr(0, length));
        break;
      }
    }
    return r.join('');
  }
  findIndex(offset) {
    let i = this.bounds.findIndex(o => o > offset);
    if (i === 0) {
      throw new Error('Chunk for offset ' + offset + ' already dropped, only available chunks from ' + this.bounds[0] + ' offset');
    }
    if (i < 0) {
      throw new Error('Chunk for offset ' + offset + ' not yet retrivied');
    }
    return i-1;
  }
}

/// @param parser Генератор, аккумулирующий блоки и возвращаающий результат разбора,
///        как только у него будет достаточно блоков для этого. Свойство `value`
///        возвращаемого объекта содержит либо результат разбора, в случае, если разбор
///        завершен, либо число, определяющее минимальное количество данных, требуемое
///        парсеру для завершения разбора
/// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
///        Может быть генератором, т.к. в его метод `next` передается число, означающее
///        количество символов, требуемое парсеру для завершения разбора текущей порции.
function _parse(parser, input) {
  // Сначала пытаемся получить результат непосредственно, возможно, что данных в буфере
  // уже достаточно
  let res = parser.next();

  // Если данных в буфере оказалось недостаточно, запрашиваем очередную порцию.
  while (!res.done) {
    // Передаем источнику размер данных, которые нам нужны для принятия решения
    let chunk = input.next(res.value);
    // Отправляем парсеру очередную порцию данных
    res = parser.next(chunk);
  }
  return res.value;
}

class State {
  constructor(buffer) {
    // Данные, доступные для разбора
    this.buffer = buffer ? buffer : '';
    // Сколько данных из буфера уже поглощено
    this.offset = 0;

    // Признак необходимости регистрации ожидаемых значений. Значения регистрируются,
    // как ожидаемые только в том случае, если он равен 0.
    this.silentFail = 0;
    // Максимальное смещение, до которого удалось добраться при разборе
    this.maxFailOffset = 0;
    // Список ожидаемых значений на смещении `maxFailOffset`.
    this.maxFailExpected = [];
  }
  /// Помещает новую порцию данных в список доступных данных для разбора
  /// @param chunk Порция данных, полученная от итератора с разбираемой последовательностью.
  /// @return `true`, если добавленная порция является последней, иначе `false`
  push(chunk) {
    if (chunk.value) {
      this.buffer += chunk.value;
    }
    return chunk.done;
  }
  neededData(count) {
    return this.offset + count - this.buffer.length;
  }
  charAt(offset) {
    return this.buffer.charAt(offset);
  }
  substr(length) {
    return this.buffer.substr(this.offset, length);
  }
  fail(expected) {
    if (this.silentFail > 0) { return; }
    if (this.offset < this.maxFailOffset) { return; }

    if (this.offset > this.maxFailOffset) {
      this.maxFailOffset = this.offset;
      this.maxFailExpected = [];
    }

    this.maxFailExpected.push(expected);
    return State.FAILED;
  }

  /// Возвращает генератор, который при каждом вызове пытается извлечь символ из
  /// потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает 1 символ из разбираемого потока и приостанавливает свою работу
  /// до его получения.
  ///
  /// Как только символ будет получен, возвращает его. Если поток окончится до того,
  /// как вернет символ, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе.
  ///
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchAny(last) {
    while (true) {
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      if (this.neededData(1) <= 0) {
        return this.charAt(this.offset++);
      }
      if (last) {
        return this.fail(State.ANY);
      }
      // В противном случае запрашиваем данные длиной как минимум в 1 символ
      // и повторяем процедуру
      last = this.push(yield 1);
    }
  }
  /// Возвращает генератор, который при каждом вызове пытается извлечь символ из
  /// потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает 1 символ из разбираемого потока и приостанавливает свою работу
  /// до его получения.
  ///
  /// Как только символ будет получен, проверяет его на соответствие указанному
  /// регулярному выражению. Если проверка будет провалена или поток окончится до того,
  /// как вернет символ, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе. В противном случае будет возвращен символ, полученный из потока.
  ///
  /// @param regexp {RegExp} Объект регулярного выражения, с которым сопоставлять полученный
  ///        из потока символ. Выражение должно ожидать только один символ на входе.
  /// @param expected {Expected} Объект, представляющий структурированную информацию об
  ///        ожидаемых парсером данных, который может быть зарегистрирован в списке ожидаемой
  ///        информации в случае, если разбор будет неуспешен.
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchClass(regexp, expected, last) {
    while (true) {
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      if (this.neededData(1) <= 0) {
        let ch = this.charAt(this.offset);
        if (regexp.test(ch)) {
          ++this.offset;
          return ch;
        }
        return this.fail(expected);
      }
      if (last) {
        return this.fail(expected);
      }
      // В противном случае запрашиваем данные длиной как минимум в 1 символ
      // и повторяем процедуру
      last = this.push(yield 1);
    }
  }
  /// Возвращает генератор, который при каждом вызове пытается извлечь `literal.length`
  /// символов из потока, если в нем имеются или могут иметься данные. В случае необходимости
  /// запрашивает недостающее количество символов из разбираемого потока и приостанавливает
  /// свою работу до их получения.
  ///
  /// Как только все символы будут получены, проверяет их на соответствие указанному
  /// литералу, с учетем флага необходимости игнорирования регистра символов при сравнении.
  /// Если проверка будет провалена или поток окончится до того, как вернет необходимое
  /// количество символов, генератор вернет объект `State.FAILED`, сигнализирующий о
  /// неуспешном разборе. В противном случае будет возвращена последовательность потока,
  /// соответствующая указанному литералу.
  ///
  /// @param literal {String} Строка, на равенство которой необходимо проверить символы в потоке.
  /// @param ignoreCase {boolean} `true`, если сравнение нужно производить без учета регистра
  ///        и `false` иначе.
  /// @param expected {Expected} Объект, представляющий структурированную информацию об
  ///        ожидаемых парсером данных, который может быть зарегистрирован в списке ожидаемой
  ///        информации в случае, если разбор будет неуспешен.
  /// @param [last] {boolean} Необязательный параметр, по умолчанию равный `false`,
  ///        сигнализирующий о том, сопоставляется ли последний блок данных из разбираемого
  ///        потока или нет. проверяетс только в том случае, если в потоке нет данных,
  ///        и если он равен `true`, запрос следующей порции из потока производиться не будет.
  *matchLiteral(literal, ignoreCase, expected, last) {
    while (true) {
      let needed = this.neededData(literal.length);
      // Если в буфере достаточно данных, возвращаем результат сопоставления
      // TODO: Включить оптимизацию для длинных строк: пытаться определить провал
      // сопоставления еще до получения всей строки
      if (needed <= 0) {
        let data = this.substr(literal.length);
        let forCompare = ignoreCase ? data.toLowerCase() : data;
        if (forCompare === literal) {
          this.offset += data.length;
          return data;
        }
        return this.fail(expected);
      }
      if (last) {
        return this.fail(expected);
      }
      // В противном случае запрашиваем данные длиной с недостающий размер строки
      // и повторяем процедуру
      last = this.push(yield needed);
    }
  }

  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseAny(input) {
    return _parse(this.matchAny(), input);
  }
  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseClass(input, regexp, expected) {
    return _parse(this.matchClass(regexp, expected), input);
  }
  /// @param input Итератор, выдающий последовательность блоков, которые нужно парсить.
  parseLiteral(input, literal, ignoreCase, expected) {
    return _parse(this.matchLiteral(literal, ignoreCase, expected), input);
  }
}
/// Константа, сигнализирующая о неуспешном разборе правила
State.FAILED = function FAILED(){};
/// Константа, описывающая ожидаемый результат любого символа последовательности
State.ANY = { type: "any" };

module.exports = State;